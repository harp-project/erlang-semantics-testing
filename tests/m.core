module 'm' ['main'/0,
	    'module_info'/0,
	    'module_info'/1]
    attributes [%% Line 1
		'file' =
		    %% Line 1
		    [{[109|[46|[101|[114|[108]]]]],1}]]
'main'/0 =
    %% Line 4
    fun () ->
	case <> of
	  <> when 'true' ->
	      %% Line 5
	      case [5|[6|[7|[8|9]]]] of
		%% Line 6
		<5> when 'true' ->
		    3
		%% Line 7
		<_1> when 'true' ->
		    2
		( <_0> when 'true' ->
		      primop 'match_fail'
			  ({'case_clause',_0})
		  -| ['compiler_generated'] )
	      end
	  ( <> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause'})
		  -| [{'function_name',{'main',0}}] )
	    -| ['compiler_generated'] )
	end
'f'/0 =
    %% Line 10
    fun () ->
	case <> of
	  <> when 'true' ->
	      ( letrec
		    'lc$^0'/1 =
			fun (_8) ->
			    case _8 of
			      <[X|_1]> when 'true' ->
				  ( letrec
					'lc$^1'/1 =
					    fun (_9) ->
						case _9 of
						  <[Y|_4]>
						      when try
							    let <_5> =
								call 'erlang':'>'
								    (Y, 3)
							    in  let <_6> =
								    call 'erlang':'<'
									(X, 4)
								in  call 'erlang':'and'
									(_5, _6)
							of <Try> ->
							    Try
							catch <T,R> ->
							    'false' ->
						      let <_10> =
							  apply 'lc$^1'/1
							      (_4)
						      in  ( [{X,Y}|_10]
							    -| ['compiler_generated'] )
						  ( <[Y|_4]> when 'true' ->
							apply 'lc$^1'/1
							    (_4)
						    -| ['compiler_generated'] )
						  <[]> when 'true' ->
						      apply 'lc$^0'/1
							  (_1)
						  ( <_9> when 'true' ->
							( primop 'match_fail'
							      ({'function_clause',_9})
							  -| [{'function_name',{'lc$^1',1}}] )
						    -| ['compiler_generated'] )
						end
				    in  let <_7> =
					    call 'lists':'seq'
						(1, 5)
					in  apply 'lc$^1'/1
						(_7)
				    -| ['list_comprehension'] )
			      <[]> when 'true' ->
				  []
			      ( <_8> when 'true' ->
				    ( primop 'match_fail'
					  ({'function_clause',_8})
				      -| [{'function_name',{'lc$^0',1}}] )
				-| ['compiler_generated'] )
			    end
		in  let <_2> =
			call 'list':'seq'
			    (1, 10)
		    in  apply 'lc$^0'/1
			    (_2)
		-| ['list_comprehension'] )
	  ( <> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause'})
		  -| [{'function_name',{'f',0}}] )
	    -| ['compiler_generated'] )
	end
'module_info'/0 =
    fun () ->
	case <> of
	  <> when 'true' ->
	      call 'erlang':'get_module_info'
		  ('m')
	  ( <> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause'})
		  -| [{'function_name',{'module_info',0}}] )
	    -| ['compiler_generated'] )
	end
'module_info'/1 =
    fun (_0) ->
	case _0 of
	  <X> when 'true' ->
	      call 'erlang':'get_module_info'
		  ('m', X)
	  ( <_1> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_1})
		  -| [{'function_name',{'module_info',1}}] )
	    -| ['compiler_generated'] )
	end
end